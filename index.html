<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MW tracker</title>
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="MW Tracker">
    <meta name="description" content="Śledzenie pociągów Metra Warszawskiego w czasie rzeczywistym">
    
    <!-- Favicons -->
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    
    <style>
        /* Custom Font */
        @font-face {
            font-family: 'CustomFont';
            src: url('font.woff2') format('woff2'),
                 url('font.woff') format('woff'),
                 url('font.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background-color: #000000;
        }

        #app-container {
            display: flex;
            height: 100vh;
        }

        #map {
            flex-grow: 1;
            height: 100%;
            background-color: #000000;
        }
        
        .train-icon {
            border-radius: 50%;
            color: rgba(255, 255, 255, 0);
            text-align: center;
            font-weight: bold;
            font-size: 12px;
            line-height: 20px;
            width: 16px;
            height: 16px;
            box-shadow: 0 0 5px rgba(255, 255, 255, 0);
            border: 2px solid rgb(0, 0, 0);
        }
        .train-icon.m1 { background-color: #000000; }
        .train-icon.m2 { background-color: #000000; }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 20px 40px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 1000;
            font-size: 18px;
            color: #333;
        }

        #loading.hidden {
            display: none;
        }

        #error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 100, 100, 0.95);
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 1000;
            color: white;
            max-width: 500px;
            display: none;
        }

        #error.show {
            display: block;
        }

        #error h3 {
            margin-top: 0;
        }

        #install-prompt {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 1000;
            display: none;
            align-items: center;
            gap: 15px;
        }

        #install-prompt.show {
            display: flex;
        }

        #install-prompt button {
            background: #000;
            color: #fff;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        #install-prompt button:hover {
            background: #333;
        }

        #install-prompt .close {
            background: transparent;
            color: #666;
            padding: 4px 8px;
        }

        #header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 30px;
            z-index: 1000;
            pointer-events: none;
        }

        #header-title {
            color: white;
            font-size: 24px;
            font-weight: 600;
            letter-spacing: 0.5px;
            font-family: 'CustomFont', 'Segoe UI', sans-serif;
        }

        #header-stats {
            display: flex;
            gap: 30px;
            align-items: center;
        }

        .stat-item {
            color: white;
            font-size: 13px;
            text-align: right;
            line-height: 1.4;
            font-family: 'CustomFont', 'Segoe UI', sans-serif;
        }

        .stat-value {
            font-size: 18px;
            font-weight: 600;
            display: block;
        }

        .stat-label {
            font-size: 11px;
            opacity: 0.8;
            font-weight: 400;
        }

        .leaflet-control-attribution {
            display: none !important;
        }
    </style>
</head>
<body>

    <div id="loading">Ładowanie danych GTFS...</div>
    <div id="error">
        <h3>Błąd wczytywania danych</h3>
        <p id="error-message"></p>
    </div>

    <div id="install-prompt">
        <span>Zainstaluj aplikację na swoim urządzeniu</span>
        <button id="install-button">Zainstaluj</button>
        <button class="close" id="close-prompt">✕</button>
    </div>

    <div id="app-container">
        <div id="header">
            <div id="header-title">Podziemie</div>
            <div id="header-stats">
                <div class="stat-item">
                    <span class="stat-value" id="total-trains">0</span>
                    <span class="stat-label">pociągów</span>
                </div>
                <div class="stat-item">
                    <span class="stat-value" id="capacity-m1">0</span>
                    <span class="stat-label">M1 ludzi/h</span>
                </div>
                <div class="stat-item">
                    <span class="stat-value" id="capacity-m2">0</span>
                    <span class="stat-label">M2 ludzi/h</span>
                </div>
            </div>
        </div>
        <main id="map"></main>
    </div>

    <script>
        // --- KONFIGURACJA UŻYTKOWNIKA ---

        const svgUrl = 'mapunia.svg'; 

        const svgBounds = [
            [52.11381-0.0051, 20.87874-0.010],
            [52.32977-0.0047, 21.14531-0.005]
        ];
        
        const zoomOffset = 2;
        const maxZoomLevel = 15;

        const gtfsFiles = {
            stops: 'stops.txt',
            routes: 'routes.txt',
            trips: 'trips.txt',
            stop_times: 'stop_times.txt',
            frequencies: 'frequencies.txt',
            calendar_dates: 'calendar_dates.txt'
        };

        // --- Koniec konfiguracji ---

        let map;
        const db = {};
        const trainMarkers = {};
        let deferredPrompt;

        // PWA Install Prompt
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            document.getElementById('install-prompt').classList.add('show');
        });

        document.getElementById('install-button').addEventListener('click', async () => {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                deferredPrompt = null;
                document.getElementById('install-prompt').classList.remove('show');
            }
        });

        document.getElementById('close-prompt').addEventListener('click', () => {
            document.getElementById('install-prompt').classList.remove('show');
        });

        // Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('service-worker.js')
                    .then(registration => console.log('SW registered:', registration))
                    .catch(err => console.log('SW registration failed:', err));
            });
        }

        function showError(message) {
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('error-message').textContent = message;
            document.getElementById('error').classList.add('show');
        }

        function parseCSV(text) {
            const lines = text.trim().split('\n');
            const header = lines.shift().split(',');
            return lines.map(line => {
                const values = line.split(',');
                return header.reduce((obj, key, i) => {
                    obj[key.trim()] = values[i] ? values[i].trim() : '';
                    return obj;
                }, {});
            });
        }

        async function loadGTFSFile(filename) {
            try {
                const response = await fetch(filename);
                if (!response.ok) {
                    throw new Error(`Nie można wczytać pliku ${filename} (HTTP ${response.status})`);
                }
                return await response.text();
            } catch (error) {
                throw new Error(`Błąd wczytywania ${filename}: ${error.message}`);
            }
        }

        async function loadAllGTFSData() {
            const gtfsData = {};
            
            try {
                for (const [key, filename] of Object.entries(gtfsFiles)) {
                    gtfsData[key] = await loadGTFSFile(filename);
                }
                return gtfsData;
            } catch (error) {
                showError(error.message + '\n\nUpewnij się, że pliki GTFS znajdują się w tym samym folderze co plik HTML.');
                throw error;
            }
        }
        
        async function init() {
            try {
                const gtfsData = await loadAllGTFSData();

                db.stops = parseCSV(gtfsData.stops).reduce((acc, stop) => {
                    acc[stop.stop_id] = {
                        id: stop.stop_id,
                        name: stop.stop_name,
                        lat: parseFloat(stop.stop_lat),
                        lon: parseFloat(stop.stop_lon)
                    };
                    return acc;
                }, {});

                db.routes = parseCSV(gtfsData.routes).reduce((acc, route) => {
                    acc[route.route_id] = route;
                    return acc;
                }, {});

                db.trips = parseCSV(gtfsData.trips);
                db.stop_times = parseCSV(gtfsData.stop_times);
                db.frequencies = parseCSV(gtfsData.frequencies);
                db.calendar_dates = parseCSV(gtfsData.calendar_dates);
                
                db.shapes = {};
                
                db.trips.forEach(trip => {
                    const stopsOnTrip = db.stop_times
                        .filter(st => st.trip_id === trip.trip_id)
                        .sort((a, b) => parseInt(a.stop_sequence) - parseInt(b.stop_sequence))
                        .map(st => db.stops[st.stop_id])
                        .filter(stop => stop);
                    
                    const shapeKey = `${trip.route_id}:${trip.direction_id}`;
                    if (!db.shapes[shapeKey] && stopsOnTrip.length > 0) {
                        db.shapes[shapeKey] = stopsOnTrip;
                    }
                });

                document.getElementById('loading').classList.add('hidden');

                initMap();
                
                updateTrains();
                setInterval(updateTrains, 500);
            } catch (error) {
                console.error('Błąd inicjalizacji:', error);
            }
        }

        function initMap() {
            map = L.map('map', {
                maxBounds: svgBounds,
                maxBoundsViscosity: 1.0,
                zoomControl: false
            });

            L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager_nolabels/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; OpenStreetMap &copy; CARTO',
                opacity: 0
            }).addTo(map);

            map.createPane('svgPane');
            map.getPane('svgPane').style.zIndex = 250;

            L.imageOverlay(svgUrl, svgBounds, {
                pane: 'svgPane',
                interactive: true
            }).addTo(map);

            for (const shapeId in db.shapes) {
                const routeId = shapeId.split(':')[0];
                const route = db.routes[routeId];
                const coordinates = db.shapes[shapeId].map(stop => [stop.lat, stop.lon]);
                L.polyline(coordinates, { color: `#${route.route_color}`, weight: 6, opacity: 0 }).addTo(map);
            }

            for (const stopId in db.stops) {
                const stop = db.stops[stopId];
                L.circleMarker([stop.lat, stop.lon], {
                    radius: 0,
                    color: '#000',
                    fillColor: '#fff',
                    fillOpacity: 0,
                    weight: 0
                }).addTo(map).bindTooltip(stop.name);
            }
            
            const center = L.latLngBounds(svgBounds).getCenter();
            const baseZoom = map.getBoundsZoom(svgBounds);
            const initialZoom = baseZoom + zoomOffset;
            
            map.setView(center, initialZoom);
            map.setMinZoom(initialZoom);
            map.setMaxZoom(maxZoomLevel);
        }

        function getServiceIdForToday() {
            const today = new Date();
            const dateStr = today.toISOString().slice(0, 10).replace(/-/g, '');
            const serviceForToday = db.calendar_dates.find(cd => cd.date === dateStr);
            return serviceForToday ? serviceForToday.service_id : 'PcM';
        }
        
        function timeToSeconds(timeStr) {
            const [h, m, s] = timeStr.split(':').map(Number);
            return h * 3600 + m * 60 + s;
        }

        function calculateTrainPosition(train) {
            const shape = db.shapes[`${train.line}:${train.direction}`];
            if (!shape || shape.length === 0) return null;

            const DURATION_PER_SEGMENT = 120;
            const DURATION_STOP = 30;         
            const DURATION_TRAVEL = DURATION_PER_SEGMENT - DURATION_STOP; 

            const segmentsElapsed = train.elapsed / DURATION_PER_SEGMENT;
            const stopIndex = Math.floor(segmentsElapsed);

            if (stopIndex >= shape.length - 1) return null;

            const currentStop = shape[stopIndex];
            const nextStop = shape[stopIndex + 1];
            const timeIntoSegment = train.elapsed % DURATION_PER_SEGMENT;

            let segmentProgress = (timeIntoSegment < DURATION_TRAVEL) ? (timeIntoSegment / DURATION_TRAVEL) : 1.0;

            const lat = currentStop.lat + (nextStop.lat - currentStop.lat) * segmentProgress;
            const lon = currentStop.lon + (nextStop.lon - currentStop.lon) * segmentProgress;

            return { lat, lon };
        }

        function updateTrains() {
            const now = new Date();
            const secondsSinceMidnight = now.getHours() * 3600 + now.getMinutes() * 60 + now.getSeconds();
            const serviceId = getServiceIdForToday();
            
            const activeTrains = [];

            db.frequencies.forEach(freq => {
                if (!freq.trip_id.includes(serviceId)) return;

                const startTime = timeToSeconds(freq.start_time);
                const endTime = timeToSeconds(freq.end_time);
                const headway = parseInt(freq.headway_secs);

                if (secondsSinceMidnight >= startTime && secondsSinceMidnight <= endTime) {
                    for (let t = startTime; t < endTime; t += headway) {
                        const elapsed = secondsSinceMidnight - t;
                        if (elapsed >= 0) {
                            const tripInfo = db.trips.find(trip => trip.trip_id === freq.trip_id);
                            if(tripInfo) {
                                activeTrains.push({
                                    id: `${tripInfo.route_id}-${tripInfo.direction_id}-${t}`,
                                    line: tripInfo.route_id,
                                    headsign: tripInfo.trip_headsign,
                                    direction: tripInfo.direction_id,
                                    elapsed: elapsed
                                });
                            }
                        }
                    }
                }
            });

            updateMap(activeTrains);
        }
        
        function updateMap(trains) {
            const activeTrainIds = new Set();
            let m1Count = 0;
            let m2Count = 0;
            
            trains.forEach(train => {
                const position = calculateTrainPosition(train);
                if (!position) return;
                
                activeTrainIds.add(train.id);

                // Zliczaj pociągi według linii
                if (train.line.toUpperCase() === 'M1') {
                    m1Count++;
                } else if (train.line.toUpperCase() === 'M2') {
                    m2Count++;
                }

                const iconHtml = `<div class="train-icon ${train.line.toLowerCase()}">${train.line}</div>`;
                const customIcon = L.divIcon({
                    html: iconHtml,
                    className: '',
                    iconSize: [24, 24],
                    iconAnchor: [12, 12]
                });

                if (trainMarkers[train.id]) {
                    trainMarkers[train.id].setLatLng([position.lat, position.lon]);
                } else {
                    trainMarkers[train.id] = L.marker([position.lat, position.lon], { icon: customIcon })
                        .addTo(map)
                        .bindTooltip(`Pociąg do: ${train.headsign}`);
                }
            });
            
            for (const trainId in trainMarkers) {
                if (!activeTrainIds.has(trainId)) {
                    map.removeLayer(trainMarkers[trainId]);
                    delete trainMarkers[trainId];
                }
            }

            // Aktualizuj statystyki w nagłówku
            const PASSENGERS_PER_TRAIN = 1500;
            const totalTrains = activeTrainIds.size;
            const m1Capacity = m1Count * PASSENGERS_PER_TRAIN;
            const m2Capacity = m2Count * PASSENGERS_PER_TRAIN;

            document.getElementById('total-trains').textContent = totalTrains;
            document.getElementById('capacity-m1').textContent = m1Capacity.toLocaleString('pl-PL');
            document.getElementById('capacity-m2').textContent = m2Capacity.toLocaleString('pl-PL');
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
