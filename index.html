<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MW tracker</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        #app-container {
            display: flex;
            height: 100vh;
        }

        #map {
            flex-grow: 1;
            height: 100%;
            background-color: #000000;
        }
        
        .train-icon {
            border-radius: 50%;
            color: rgba(255, 255, 255, 0);
            text-align: center;
            font-weight: bold;
            font-size: 12px;
            line-height: 20px;
            width: 20px;
            height: 20px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0);
            border: 2px solid rgb(255, 255, 255);
        }
        .train-icon.m1 { background-color: #ffffff00; }
        .train-icon.m2 { background-color: #bb000000; }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 20px 40px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 1000;
            font-size: 18px;
            color: #333;
        }

        #loading.hidden {
            display: none;
        }

        #error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 100, 100, 0.95);
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 1000;
            color: white;
            max-width: 500px;
            display: none;
        }

        #error.show {
            display: block;
        }

        #error h3 {
            margin-top: 0;
        }

    </style>
</head>
<body>

    <div id="loading">Ładowanie danych GTFS...</div>
    <div id="error">
        <h3>Błąd wczytywania danych</h3>
        <p id="error-message"></p>
    </div>

    <div id="app-container">
        <main id="map"></main>
    </div>

    <script>
        // --- KONFIGURACJA UŻYTKOWNIKA ---

        const svgUrl = 'mapunia2.svg'; 

        const svgBounds = [
    [52.11381-0.0051, 20.87874-0.010],  // Lewy dolny róg (SW)
    [52.32977-0.0047, 21.14531-0.005]   // Prawy górny róg (NE)
];
        
        const zoomOffset = 2;
        const maxZoomLevel = 15;

        // Pliki GTFS do wczytania
        const gtfsFiles = {
            stops: 'stops.txt',
            routes: 'routes.txt',
            trips: 'trips.txt',
            stop_times: 'stop_times.txt',
            frequencies: 'frequencies.txt',
            calendar_dates: 'calendar_dates.txt'
        };

        // --- Koniec konfiguracji ---

        let map;
        const db = {};
        const trainMarkers = {};

        function showError(message) {
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('error-message').textContent = message;
            document.getElementById('error').classList.add('show');
        }

        function parseCSV(text) {
            const lines = text.trim().split('\n');
            const header = lines.shift().split(',');
            return lines.map(line => {
                const values = line.split(',');
                return header.reduce((obj, key, i) => {
                    obj[key.trim()] = values[i] ? values[i].trim() : '';
                    return obj;
                }, {});
            });
        }

        async function loadGTFSFile(filename) {
            try {
                const response = await fetch(filename);
                if (!response.ok) {
                    throw new Error(`Nie można wczytać pliku ${filename} (HTTP ${response.status})`);
                }
                return await response.text();
            } catch (error) {
                throw new Error(`Błąd wczytywania ${filename}: ${error.message}`);
            }
        }

        async function loadAllGTFSData() {
            const gtfsData = {};
            
            try {
                // Wczytaj wszystkie pliki GTFS
                for (const [key, filename] of Object.entries(gtfsFiles)) {
                    gtfsData[key] = await loadGTFSFile(filename);
                }
                return gtfsData;
            } catch (error) {
                showError(error.message + '\n\nUpewnij się, że pliki GTFS znajdują się w tym samym folderze co plik HTML.');
                throw error;
            }
        }
        
        async function init() {
            try {
                // Wczytaj dane GTFS z plików
                const gtfsData = await loadAllGTFSData();

                // Przetwórz stops
                db.stops = parseCSV(gtfsData.stops).reduce((acc, stop) => {
                    acc[stop.stop_id] = {
                        id: stop.stop_id,
                        name: stop.stop_name,
                        lat: parseFloat(stop.stop_lat),
                        lon: parseFloat(stop.stop_lon)
                    };
                    return acc;
                }, {});

                // Przetwórz routes
                db.routes = parseCSV(gtfsData.routes).reduce((acc, route) => {
                    acc[route.route_id] = route;
                    return acc;
                }, {});

                // Przetwórz trips
                db.trips = parseCSV(gtfsData.trips);

                // Przetwórz stop_times
                db.stop_times = parseCSV(gtfsData.stop_times);

                // Przetwórz frequencies
                db.frequencies = parseCSV(gtfsData.frequencies);

                // Przetwórz calendar_dates
                db.calendar_dates = parseCSV(gtfsData.calendar_dates);
                
                // Budowanie kształtów tras z stop_times
                db.shapes = {};
                
                db.trips.forEach(trip => {
                    const stopsOnTrip = db.stop_times
                        .filter(st => st.trip_id === trip.trip_id)
                        .sort((a, b) => parseInt(a.stop_sequence) - parseInt(b.stop_sequence))
                        .map(st => db.stops[st.stop_id])
                        .filter(stop => stop);
                    
                    const shapeKey = `${trip.route_id}:${trip.direction_id}`;
                    if (!db.shapes[shapeKey] && stopsOnTrip.length > 0) {
                        db.shapes[shapeKey] = stopsOnTrip;
                    }
                });

                // Ukryj komunikat ładowania
                document.getElementById('loading').classList.add('hidden');

                initMap();
                
                updateTrains();
                setInterval(updateTrains, 500);
            } catch (error) {
                console.error('Błąd inicjalizacji:', error);
            }
        }

        function initMap() {
            map = L.map('map', {
                maxBounds: svgBounds,
                maxBoundsViscosity: 1.0,
                zoomControl: false
            });

            L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager_nolabels/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; OpenStreetMap &copy; CARTO',
                opacity: 0
            }).addTo(map);

            map.createPane('svgPane');
            map.getPane('svgPane').style.zIndex = 250;

            L.imageOverlay(svgUrl, svgBounds, {
                pane: 'svgPane',
                interactive: true
            }).addTo(map);

            for (const shapeId in db.shapes) {
                const routeId = shapeId.split(':')[0];
                const route = db.routes[routeId];
                const coordinates = db.shapes[shapeId].map(stop => [stop.lat, stop.lon]);
                L.polyline(coordinates, { color: `#${route.route_color}`, weight: 6, opacity: 0.8 }).addTo(map);
            }

            for (const stopId in db.stops) {
                const stop = db.stops[stopId];
                L.circleMarker([stop.lat, stop.lon], {
                    radius: 4,
                    color: '#000',
                    fillColor: '#fff',
                    fillOpacity: 1,
                    weight: 2
                }).addTo(map).bindTooltip(stop.name);
            }
            
            const center = L.latLngBounds(svgBounds).getCenter();
            const baseZoom = map.getBoundsZoom(svgBounds);
            const initialZoom = baseZoom + zoomOffset;
            
            map.setView(center, initialZoom);
            map.setMinZoom(initialZoom);
            map.setMaxZoom(maxZoomLevel);
        }

        function getServiceIdForToday() {
            const today = new Date();
            const dateStr = today.toISOString().slice(0, 10).replace(/-/g, '');
            
            // Znajdź service_id dla dzisiejszej daty
            const serviceForToday = db.calendar_dates.find(cd => cd.date === dateStr);
            
            return serviceForToday ? serviceForToday.service_id : 'PcM'; // domyślnie dzień powszedni
        }
        
        function timeToSeconds(timeStr) {
            const [h, m, s] = timeStr.split(':').map(Number);
            return h * 3600 + m * 60 + s;
        }

        function calculateTrainPosition(train) {
            const shape = db.shapes[`${train.line}:${train.direction}`];
            if (!shape || shape.length === 0) return null;

            const DURATION_PER_SEGMENT = 120;
            const DURATION_STOP = 30;         
            const DURATION_TRAVEL = DURATION_PER_SEGMENT - DURATION_STOP; 

            const segmentsElapsed = train.elapsed / DURATION_PER_SEGMENT;
            const stopIndex = Math.floor(segmentsElapsed);

            if (stopIndex >= shape.length - 1) return null;

            const currentStop = shape[stopIndex];
            const nextStop = shape[stopIndex + 1];
            const timeIntoSegment = train.elapsed % DURATION_PER_SEGMENT;

            let segmentProgress = (timeIntoSegment < DURATION_TRAVEL) ? (timeIntoSegment / DURATION_TRAVEL) : 1.0;

            const lat = currentStop.lat + (nextStop.lat - currentStop.lat) * segmentProgress;
            const lon = currentStop.lon + (nextStop.lon - currentStop.lon) * segmentProgress;

            return { lat, lon };
        }

        function updateTrains() {
            const now = new Date();
            const secondsSinceMidnight = now.getHours() * 3600 + now.getMinutes() * 60 + now.getSeconds();
            const serviceId = getServiceIdForToday();
            
            const activeTrains = [];

            db.frequencies.forEach(freq => {
                // Sprawdź czy trip_id pasuje do aktualnego service_id
                if (!freq.trip_id.includes(serviceId)) return;

                const startTime = timeToSeconds(freq.start_time);
                const endTime = timeToSeconds(freq.end_time);
                const headway = parseInt(freq.headway_secs);

                if (secondsSinceMidnight >= startTime && secondsSinceMidnight <= endTime) {
                    for (let t = startTime; t < endTime; t += headway) {
                        const elapsed = secondsSinceMidnight - t;
                        if (elapsed >= 0) {
                            const tripInfo = db.trips.find(trip => trip.trip_id === freq.trip_id);
                            if(tripInfo) {
                                activeTrains.push({
                                    id: `${tripInfo.route_id}-${tripInfo.direction_id}-${t}`,
                                    line: tripInfo.route_id,
                                    headsign: tripInfo.trip_headsign,
                                    direction: tripInfo.direction_id,
                                    elapsed: elapsed
                                });
                            }
                        }
                    }
                }
            });

            updateMap(activeTrains);
        }
        
        function updateMap(trains) {
            const activeTrainIds = new Set();
            
            trains.forEach(train => {
                const position = calculateTrainPosition(train);
                if (!position) return;
                
                activeTrainIds.add(train.id);

                const iconHtml = `<div class="train-icon ${train.line.toLowerCase()}">${train.line}</div>`;
                const customIcon = L.divIcon({
                    html: iconHtml,
                    className: '',
                    iconSize: [24, 24],
                    iconAnchor: [12, 12]
                });

                if (trainMarkers[train.id]) {
                    trainMarkers[train.id].setLatLng([position.lat, position.lon]);
                } else {
                    trainMarkers[train.id] = L.marker([position.lat, position.lon], { icon: customIcon })
                        .addTo(map)
                        .bindTooltip(`Pociąg do: ${train.headsign}`);
                }
            });
            
            for (const trainId in trainMarkers) {
                if (!activeTrainIds.has(trainId)) {
                    map.removeLayer(trainMarkers[trainId]);
                    delete trainMarkers[trainId];
                }
            }
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
